#include "App.h"

#include <iostream>
#include <string>

using namespace std;


/*
    
   см -- region OBJECTIVE


*/


#define space std::cout << "\n\n"
#define tab std::cout<<"\t"


#define INDEX 48 // Номер единицы в табице чаров



#pragma region OBJECTIVE

/*

    Создать простой статический ассоциативный массив (наивную реализацию) -- MapX.h

    Ассоциативным является тот массив, значения в котором ассоциированы с их ключами.
    Например, карточка клиента - это значение, а идентификатор клиента - это ключ.

    Класс должен быть шаблонным и должен содержать тип TKey и тип TValue соответственно.
    Кроме того, мы должны иметь возможность задать размер массива при объявлении экземпляра шаблона:

    template <typename TKey, typename TValue, size_t size> - пример указания типов шаблона

    Класс должен содержать:
    - необходимые конструкторы  .............................................................................................................    MapX.h region CONSTRUCT;
    - как минимум должны быть перегружены операторы присваивания и индексации(индексировать необходимо по ключу, а не по индексу)   ..    MapX.h line 72, MapX.h line 90;
    - другие необходимые перегрузки операторов  ...............................................................................................................   MapX.h;
    - метод добавления значений (добавлять следует до тех пор, пока массив не наполнится полностью) ....................................................  Map.h line 158;
    - метод, проверяющий наличие ключа в массиве    ....................................................................................................  Map.h line 188;
    - метод поиска по ключу ............................................................................................................................  Map.h line 203;
    - метод обновления значения по ключу    ...........................................................................................................  MapX.h line 219;

    Класс реализовать простым способом. Делать реализацию хэш-таблицы НЕ НУЖНО!!!


*/

#pragma endregion OBJECTIVE




#pragma region CONSTRUCT


App::App()
{

}


#pragma endregion CONSTRUCT





void App::run()
{
    

#pragma region DEMO


    // Создание первой коллекции
    MapX<int, double> sub;

    //Добавление двух эл-тов
    sub.put(1, 2.0);
    sub.put(2, 3.14);

    // Вывод первой в консоль
    sub.forEach(std::cout);

    // Создание второй коллекции
    MapX<int, double> sub1;

    // Приравнивание второй к первой
    sub1 = sub;

    std::cout << "\n\n";

    // Вывод второй в консоль
    sub1.forEach(std::cout);

    std::cout << "\n\n";

    // Проверка на содержание ключа
    std::cout << sub1.containsKey(1);

    std::cout << "\n\n";

    // Получение порядкового номера через ключ
    std::cout << sub1.findKey(1);

    // Изменение значения по ключу
    sub1.renew(1, 50.0);

    std::cout << "\n\n";

    // Вывод второго в консоль, чтобы посмотреть изменение
    sub1.forEach(std::cout);

    std::cout << "\n\n";

    // Получение ключа по порядковому номеру (аналог findKey())
    std::cout << sub1[1];


#pragma endregion DEMO



}

